use std::collections::HashSet;

type Input = Vec<Sensor>;

#[derive(Debug, Clone, Hash, Eq)]
pub struct Point {
    x: isize,
    y: isize,
}

impl Point {
    pub fn manhattan_distance(&self, other: &Point) -> isize {
        (self.x - other.x).abs() + (self.y - other.y).abs()
    }
}

impl PartialEq for Point {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}

// impl Copy for Point {}

// impl Clone for Point {
//     fn clone(&self) -> Point {
//         *self
//     }
// }

pub struct Sensor {
    at: Point,
    closest_beacon: Point,
}

pub fn parse_point(s: &str) -> Option<Point> {
    let (_, point_str) = s.split_once("at")?;
    let (x_str, y_str) = point_str.split_once(", ")?;
    let (_, x) = x_str.split_once("=")?;
    let (_, y) = y_str.split_once("=")?;
    Some(Point {
        x: x.parse().ok()?,
        y: y.parse().ok()?,
    })
}

pub fn parse(input: &str) -> Input {
    input
        .lines()
        .filter_map(|line| {
            let (sensor_str, beacon_str) = line.split_once(":")?;
            Some(Sensor {
                at: parse_point(sensor_str)?,
                closest_beacon: parse_point(beacon_str)?,
            })
        })
        .collect()
}

pub fn get_border(sensor: &Sensor) -> Vec<Point> {
    let dist = sensor.at.manhattan_distance(&sensor.closest_beacon);
    let mut result = vec![];
    for i in 0..dist + 2 {
        result.push(Point {
            x: sensor.at.x + dist - i + 1,
            y: sensor.at.y - i,
        });
        result.push(Point {
            x: sensor.at.x - dist + i - 1,
            y: sensor.at.y - i,
        });
        result.push(Point {
            x: sensor.at.x - dist + i - 1,
            y: sensor.at.y + i,
        });
        result.push(Point {
            x: sensor.at.x + dist - i + 1,
            y: sensor.at.y + i,
        });
    }
    result
}

pub fn print_border(sensor: &Sensor) {
    let borders = get_border(sensor);
    for i in -2..23 {
        print!("{:02} ", i);
        for j in -2..26 {
            if (Point { x: j, y: i }) == sensor.at {
                print!("S");
            } else if (Point { x: j, y: i }) == sensor.closest_beacon {
                print!("B");
            } else if borders.contains(&Point { x: j, y: i }) {
                print!("#");
            } else {
                print!(".");
            }
        }
        println!("");
    }
}

pub fn part_one(input: &str) -> Option<usize> {
    let input = parse(input);
    let target_row = if cfg!(test) { 10 } else { 2000000 };
    let mut beacons = HashSet::new();
    input.iter().for_each(|sensor| {
        let max_distance = sensor.at.manhattan_distance(&sensor.closest_beacon);
        let max_y = sensor.at.y + max_distance;
        let min_y = sensor.at.y - max_distance;

        if min_y <= target_row && target_row <= max_y {
            let min_x = sensor.at.x - ((sensor.at.y - target_row).abs() - max_distance).abs();
            let max_x = sensor.at.x + ((sensor.at.y - target_row).abs() - max_distance).abs();
            for x in min_x..max_x {
                beacons.insert((x, target_row));
            }
        }
    });
    Some(beacons.len())
}

pub fn part_two(input: &str) -> Option<usize> {
    let input = parse(input);
    let mut borders = HashSet::new();
    let mut tmp_borders = vec![];
    input.iter().for_each(|sensor| {
        tmp_borders = get_border(sensor);
        tmp_borders.iter().for_each(|point| {
            if !borders.contains(point) && 0 < point.x && point.x < 20 && 0 < point.y && point.y < 20 {
                borders.insert(point.clone());
            } else {
                borders.remove(point);
            }
        })
    });
    Some(borders.len())
}

fn main() {
    let input = &advent_of_code::read_file("inputs", 15);
    advent_of_code::solve!(1, part_one, input);
    advent_of_code::solve!(2, part_two, input);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_part_one() {
        let input = advent_of_code::read_file("examples", 15);
        assert_eq!(part_one(&input), Some(26));
    }

    #[test]
    fn test_part_two() {
        let input = advent_of_code::read_file("examples", 15);
        assert_eq!(part_two(&input), Some(1));
    }

    // #[test]
    // fn test_get_border() {
    //     print_border(&Sensor {
    //         at: Point { x: 8, y: 7 },
    //         closest_beacon: Point { x: 6, y: 8 },
    //     });
    //     assert_eq!(
    //         get_border(&Sensor {
    //             at: Point { x: 8, y: 7 },
    //             closest_beacon: Point { x: 6, y: 8 }
    //         }),
    //         []
    //     );
    // }
}
